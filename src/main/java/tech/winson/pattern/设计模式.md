# 创建形模式 创-建原工单
## 建造者模式
构建过程与具体细节相分离，使得相同的构建过程可以创建不同的表示；
使用多个简单的对象一步一步构建成一个复杂的对象。一个 Builder 类会一步一步构造最终的对象。
该 Builder 类是独立于其他对象的。(KFC)
## 原型模式
这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。
当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。
我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 (Object.clone)
## 工厂模式
创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
## 单例模式
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。
这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

# 结构型模式 结-适享外代过组装桥
## 适配器模式
作为两个不兼容的接口之间的桥梁(读卡器)
## 享元模式
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。(String)
## 外观模式
隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。
这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。
为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。(MVC)
## 代理模式
创建具有现有对象的对象，以便向外界提供功能接口。
为其他对象提供一种代理以控制对这个对象的访问。(AOP)
## 过滤器模式
使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。
## 组合模式
用于把一组相似的对象当作一个单一的对象。
组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种模式创建了一个包含自己对象组的类。
该类提供了修改相同对象组的方式。
对象组合成树形结构以表示"部分-整体"的层次结构
## 装饰器模式
向一个现有的对象添加新的功能，同时又不改变其结构。
创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
(继承父类，扩展功能)
## 桥接模式
用于把抽象化与实现化解耦，使得二者可以独立变化。
抽象和实现的分离(面向接口编程)

# 行为型模式 行-观摩解策中空迭备责命状
## 观察者模式
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
(事件、事件源与监听器)
## 模板模式
一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
Spring JPATemplate
## 解释器模式
实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
## 策略模式
一个类的行为或其算法可以在运行时更改。
创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。
(一个系统需要动态地在几种算法中选择一种)
## 中介模式
用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。
MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。
## 空对象模式
一个空对象取代NULL对象实例的检查。
Null对象不是检查空值，而是反应一个不做任何动作的关系。这样的Null对象也可以在数据不可用的时候提供默认的行为。
创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，
该空对象类将无缝地使用在需要检查空值的地方。
## 迭代器模式
用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
JAVA 中的 iterator  next  hasNext
## 备忘录模式
保存一个对象的某个状态，以便在适当的时候恢复对象。
在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
打游戏时的存档;ctrl+z;IE中的后退;数据库的事务管理
## 责任链模式
为请求创建了一个接收者对象的链。对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
Apache Tomcat对Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。
## 命令模式
请求以命令的形式包裹在对象中，并传给调用对象。
调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。
struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。
## 状态模式
类的行为是基于它的状态改变的。
在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。

